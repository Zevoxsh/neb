<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewPort" content="width=device-width, initial-scale=1.0">
    <title>Configuration - Nebula Proxy</title>
    <link rel="stylesheet" href="/public/styles.css">
    <style>
        .config-tabs {
            display: flex;
            gap: 8px;
            margin-bottom: 24px;
            border-bottom: 1px solid var(--border);
            flex-wrap: wrap;
        }

        .config-tab {
            padding: 12px 20px;
            background: transparent;
            border: none;
            color: var(--text-muted);
            cursor: pointer;
            transition: all 0.3s;
            border-bottom: 2px solid transparent;
            font-weight: 500;
        }

        .config-tab:hover {
            color: var(--text-main);
        }

        .config-tab.active {
            color: var(--primary);
            border-bottom-color: var(--primary);
        }

        .config-section {
            display: none;
        }

        .config-section.active {
            display: block;
        }

        .config-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 24px;
        }

        .config-item label {
            display: block;
            color: var(--text-main);
            font-weight: 500;
            margin-bottom: 8px;
            font-size: 14px;
        }

        .config-item input[type="checkbox"] {
            width: auto;
            margin-right: 8px;
        }

        .save-indicator {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: var(--primary);
            color: var(--bg-deep);
            padding: 12px 24px;
            border-radius: var(--radius-md);
            font-weight: 600;
            display: none;
            animation: slideIn 0.3s;
            z-index: 1000;
        }

        .save-indicator.success {
            background: var(--success);
        }

        .save-indicator.error {
            background: var(--danger);
            color: #fff;
        }

        @keyframes slideIn {
            from {
                transform: translateY(100px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .db-alert {
            background: rgba(255, 51, 51, 0.1);
            border: 1px solid var(--danger);
            border-radius: var(--radius-md);
            padding: 16px 20px;
            margin-bottom: 24px;
            display: none;
            align-items: center;
            gap: 12px;
        }

        .db-alert.show {
            display: flex;
        }

        .db-alert-icon {
            font-size: 24px;
        }

        .db-alert-content {
            flex: 1;
        }

        .db-alert-title {
            color: var(--danger);
            font-weight: 600;
            margin-bottom: 4px;
        }

        .db-alert-message {
            color: var(--text-muted);
            font-size: 14px;
        }

        .db-alert-actions {
            display: flex;
            gap: 8px;
        }
    </style>
</head>
<body data-page="config">
    <div class="app-shell">
        <div id="sidebar-placeholder"></div>
        <div class="app-main">
            <header class="topbar">
                <div class="page-heading">
                    <p class="eyebrow">System</p>
                    <h1>Configuration</h1>
                    <p class="muted">Centralized management of all settings</p>
                </div>
                <div class="topbar-actions">
                    <button onclick="showRuntimeDebug()" class="btn ghost small" title="Voir les Current Runtime Values">Debug</button>
                    <button onclick="exPortEnv()" class="btn ghost">Export .env</button>
                    <button onclick="saveAll()" class="btn">Save All</button>
                    <button onclick="restartApp()" class="btn ghost" id="restartBtn" style="display: none;">Restart</button>
                </div>
            </header>
            
            <section class="page-content">
                <div id="dbAlert" class="db-alert">
                    <div class="db-alert-icon">⚠️</div>
                    <div class="db-alert-content">
                        <div class="db-alert-title">Database connection failed</div>
                        <div class="db-alert-message" id="dbAlertMessage">Unable to connect to PostgreSQL database</div>
                    </div>
                    <div class="db-alert-actions">
                        <button onclick="testDatabaseConnection()" class="btn ghost" id="testDbBtn">Test Connection</button>
                    </div>
                </div>
                <div class="config-tabs" id="categoryTabs"></div>
                <div id="categoryContent"></div>
            </section>
            
            <div id="footer-placeholder"></div>
        </div>
    </div>

    <div id="saveIndicator" class="save-indicator"></div>

    <script src="/public/js/include-partials.js"></script>
    <script src="/public/js/api.js"></script>
    <script>
        let configData = {};
        let configSchema = {};
        let unsavedChanges = new Set();

        // Wait for api.js to load
        window.addEventListener('DOMContentLoaded', () => {
            setTimeout(() => {
                loadConfig();
                checkDatabaseConnection();
            }, 100);
        });

        async function checkDatabaseConnection() {
            try {
                if (typeof api === 'undefined') {
                    setTimeout(checkDatabaseConnection, 200);
                    return;
                }

                const response = await fetch('/api/config/test-db', {
                    method: 'GET',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    credentials: 'include'
                });

                const result = await response.json();
                
                if (!result.success) {
                    showDatabaseAlert(result.error || 'Database connection failed');
                } else {
                    hideDatabaseAlert();
                }
            } catch (error) {
                console.error('Failed to check database:', error);
                showDatabaseAlert('Unable to verify database connection');
            }
        }

        function showDatabaseAlert(message) {
            const alert = document.getElementById('dbAlert');
            const messageEl = document.getElementById('dbAlertMessage');
            messageEl.textContent = message;
            alert.classList.add('show');
        }

        function hideDatabaseAlert() {
            const alert = document.getElementById('dbAlert');
            alert.classList.remove('show');
        }

        async function testDatabaseConnection() {
            const btn = document.getElementById('testDbBtn');
            const originalText = btn.textContent;
            btn.textContent = '⏳ Test en cours...';
            btn.disabled = true;

            try {
                const response = await fetch('/api/config/test-db', {
                    method: 'GET',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    credentials: 'include'
                });

                const result = await response.json();
                
                if (result.success) {
                    hideDatabaseAlert();
                    showNotification('✓ Database connection successful', 'success');
                } else {
                    showDatabaseAlert(result.error || 'Connection failed');
                    showNotification('Connection failed: ' + result.error, 'error');
                }
            } catch (error) {
                console.error('Test failed:', error);
                showNotification('Connection test error', 'error');
            } finally {
                btn.textContent = originalText;
                btn.disabled = false;
            }
        }

        async function loadConfig() {
            try {
                if (typeof api === 'undefined') {
                    console.error('API not loaded yet, retrying...');
                    setTimeout(loadConfig, 200);
                    return;
                }
                
                const data = await api.get('/api/config');
                configData = data.config;
                configSchema = data.schema;
                renderConfig();
            } catch (error) {
                console.error('Failed to load config:', error);
                showNotification('Configuration loading error', 'error');
            }
        }

        function renderConfig() {
            const categories = Object.keys(configSchema);
            
            const tabsHtml = categories.map(cat => `
                <button class="config-tab ${cat === categories[0] ? 'active' : ''}" 
                        onclick="switchCategory('${cat}')">
                    ${getCategoryIcon(cat)} ${getCategoryLabel(cat)}
                </button>
            `).join('');
            document.getElementById('categoryTabs').innerHTML = tabsHtml;

            const contentHtml = categories.map(cat => `
                <article class="card config-section ${cat === categories[0] ? 'active' : ''}" 
                     id="category-${cat}">
                    <div class="card-header">
                        <div>
                            <p class="eyebrow">${getCategoryLabel(cat)}</p>
                            <h2>Configuration</h2>
                        </div>
                        <button class="btn ghost small" onclick="resetCategory('${cat}')">
                            Reset
                        </button>
                    </div>
                    <div class="config-grid">
                        ${renderCategoryFields(cat)}
                    </div>
                </article>
            `).join('');
            document.getElementById('categoryContent').innerHTML = contentHtml;
        }

        function renderCategoryFields(category) {
            const fields = configSchema[category];
            
            // Special message for database
            let headerMessage = '';
            if (category === 'database') {
                headerMessage = `
                    <div class="alert alert-info" style="margin-bottom: 20px;">
                        These settings modify the <code>.env</code> file. Application restart will be required after save.
                    </div>
                `;
            }
            
            const fieldsHtml = Object.entries(fields).map(([key, schema]) => {
                const value = configData[category][key];
                const fieldId = `${category}.${key}`;
                const required = schema.required ? '*' : '';

                let inputHtml = '';
                if (schema.type === 'boolean') {
                    inputHtml = `
                        <label style="display: flex; align-items: center; cursor: pointer;">
                            <input type="checkbox" id="${fieldId}" ${value ? 'checked' : ''}
                                   onchange="markChanged('${category}', '${key}', this.checked, ${schema.requiresRestart || false})">
                            <span>${getFieldLabel(key)}</span>
                        </label>
                    `;
                } else if (schema.type === 'password') {
                    inputHtml = `
                        <label>${getFieldLabel(key)}${required}</label>
                        <input type="password" id="${fieldId}" value="${value || ''}" 
                               placeholder="${schema.default}"
                               onchange="markChanged('${category}', '${key}', this.value, ${schema.requiresRestart || false})">
                    `;
                } else if (schema.type === 'number') {
                    const unit = schema.unit ? ` ${schema.unit}` : '';
                    inputHtml = `
                        <label>${getFieldLabel(key)}${required}</label>
                        <input type="number" id="${fieldId}" value="${value || schema.default}"
                               min="${schema.min || 0}" max="${schema.max || 999999}"
                               onchange="markChanged('${category}', '${key}', Number(this.value), ${schema.requiresRestart || false})"
                               placeholder="${schema.default}${unit}">
                    `;
                } else if (schema.type === 'array') {
                    inputHtml = `
                        <label>${getFieldLabel(key)}${required}</label>
                        <input type="text" id="${fieldId}" 
                               value="${Array.isArray(value) ? value.join(', ') : ''}"
                               placeholder="Comma-separated values"
                               onchange="markChanged('${category}', '${key}', this.value.split(',').map(v => v.trim()), ${schema.requiresRestart || false})">
                    `;
                } else {
                    inputHtml = `
                        <label>${getFieldLabel(key)}${required}</label>
                        <input type="text" id="${fieldId}" value="${value || ''}" 
                               placeholder="${schema.default}"
                               onchange="markChanged('${category}', '${key}', this.value, ${schema.requiresRestart || false})">
                    `;
                }

                return `
                    <div class="config-item">
                        ${inputHtml}
                        ${getHelpText(key, schema)}
                    </div>
                `;
            }).join('');
            
            return headerMessage + fieldsHtml;
        }

        function switchCategory(category) {
            document.querySelectorAll('.config-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            event.target.classList.add('active');

            document.querySelectorAll('.config-section').forEach(content => {
                content.classList.remove('active');
            });
            document.getElementById(`category-${category}`).classList.add('active');
        }

        function markChanged(category, key, value, requiresRestart = false) {
            configData[category][key] = value;
            const changeKey = `${category}.${key}`;
            unsavedChanges.add(changeKey);
            
            // Mark if requires restart
            if (requiresRestart) {
                if (!window.changesRequiringRestart) {
                    window.changesRequiringRestart = new Set();
                }
                window.changesRequiringRestart.add(changeKey);
            }
            
            clearTimeout(window.autoSaveTimer);
            window.autoSaveTimer = setTimeout(() => {
                saveChanges(category, key, value, requiresRestart);
            }, 1000);
        }

        async function saveChanges(category, key, value, requiresRestart = false) {
            try {
                if (requiresRestart) {
                    // Save dans le .env
                    const updates = {};
                    updates[key] = value;
                    
                    const response = await fetch('/api/config/update-env', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        credentials: 'include',
                        body: JSON.stringify({ category, updates })
                    });
                    
                    const result = await response.json();
                    
                    unsavedChanges.delete(`${category}.${key}`);
                    showNotification('✓ Saved in .env - Restart required', 'success');
                    
                    // Show restart button
                    const restartBtn = document.getElementById('restartBtn');
                    if (restartBtn) {
                        restartBtn.style.display = 'inline-block';
                    }
                } else {
                    // Save en DB (comPortement normal)
                    await api.put('/api/config', { category, key, value });
                    unsavedChanges.delete(`${category}.${key}`);
                    showNotification('✓ Saved', 'success');
                }
            } catch (error) {
                console.error('Failed to save:', error);
                showNotification('Error de sauvegarde', 'error');
            }
        }

        async function saveAll() {
            if (unsavedChanges.size === 0) {
                showNotification('No changes to save', 'success');
                return;
            }

            const dbUpdates = [];
            const envUpdatesByCategory = {};
            let hasEnvChanges = false;
            
            // Separate DB vs .env changes
            for (const changeKey of unsavedChanges) {
                const [category, field] = changeKey.split('.');
                const schema = configSchema[category]?.[field];
                
                if (schema?.requiresRestart) {
                    if (!envUpdatesByCategory[category]) {
                        envUpdatesByCategory[category] = {};
                    }
                    envUpdatesByCategory[category][field] = configData[category][field];
                    hasEnvChanges = true;
                } else {
                    dbUpdates.push({
                        category,
                        key: field,
                        value: configData[category][field]
                    });
                }
            }

            try {
                // Save .env changes by category
                for (const [category, updates] of Object.entries(envUpdatesByCategory)) {
                    await fetch('/api/config/update-env', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        credentials: 'include',
                        body: JSON.stringify({ category, updates })
                    });
                }
                
                // Save les changements DB
                if (dbUpdates.length > 0) {
                    await api.post('/api/config/bulk', { updates: dbUpdates });
                }
                
                unsavedChanges.clear();
                
                if (hasEnvChanges) {
                    showNotification(`✓ .env file updated - RESTART REQUIRED`, 'success');
                    const restartBtn = document.getElementById('restartBtn');
                    if (restartBtn) {
                        restartBtn.style.display = 'inline-block';
                    }
                } else {
                    showNotification(`✓ ${dbUpdates.length} settings saved`, 'success');
                }
            } catch (error) {
                console.error('Failed to save all:', error);
                showNotification('Error de sauvegarde', 'error');
            }
        }

        async function restartApp() {
            if (!confirm('Reload configuration now? New database values will be applied.')) {
                return;
            }
            
            const restartBtn = document.getElementById('restartBtn');
            restartBtn.disabled = true;
            restartBtn.textContent = 'ReLoading...';
            
            showNotification('Reloading configuration...', 'success');
            
            try {
                const response = await fetch('/api/system/restart', {
                    method: 'POST',
                    credentials: 'include'
                });
                
                const result = await response.json();
                
                if (result.success) {
                    if (result.dbConnected) {
                        showNotification('✓ Configuration reloaded - Database reconnected!', 'success');
                        
                        // Masquer le bouton restart et l'alerte DB
                        restartBtn.style.display = 'none';
                        hideDatabaseAlert();
                        
                        // Reload page after short delay
                        setTimeout(() => {
                            window.location.reload();
                        }, 1500);
                    } else {
                        showNotification('⚠️ Configuration reloaded but DB remains unreachable: ' + (result.error || 'Unknown error'), 'error');
                        restartBtn.disabled = false;
                        restartBtn.textContent = 'Restart';
                        
                        // Check DB connection again
                        setTimeout(checkDatabaseConnection, 1000);
                    }
                } else {
                    showNotification('Reload failed: ' + (result.message || 'Unknown error'), 'error');
                    restartBtn.disabled = false;
                    restartBtn.textContent = 'Restart';
                }
            } catch (error) {
                console.error('Restart error:', error);
                showNotification('Error reloading configuration', 'error');
                restartBtn.disabled = false;
                restartBtn.textContent = 'Restart';
            }
        }

        async function resetCategory(category) {
            if (!confirm(`Reset all settings for ${getCategoryLabel(category)}?`)) {
                return;
            }

            try {
                await api.post('/api/config/reset', { category });
                await loadConfig();
                showNotification('✓ Reset', 'success');
            } catch (error) {
                console.error('Failed to reset:', error);
                showNotification('Error', 'error');
            }
        }

        async function exPortEnv() {
            window.location.href = '/api/config/exPort';
        }

        function showNotification(message, type = 'success') {
            const indicator = document.getElementById('saveIndicator');
            indicator.textContent = message;
            indicator.className = `save-indicator ${type}`;
            indicator.style.display = 'block';
            
            setTimeout(() => {
                indicator.style.display = 'none';
            }, 3000);
        }

        function getCategoryIcon(category) {
            const icons = {
                database: '',
                security: '',
                acme: '',
                botProtection: '',
                backends: '',
                alerts: '',
                ipSecurity: '',
                metrics: ''
            };
            return icons[category] || '';
        }

        function getCategoryLabel(category) {
            const labels = {
                database: 'Database',
                security: 'Security & JWT',
                acme: 'SSL / Let\'s Encrypt',
                botProtection: 'Bot / DDoS Protection',
                backends: 'Backends & Health Check',
                alerts: 'Alerts',
                ipSecurity: 'IP Security',
                metrics: 'Metrics'
            };
            return labels[category] || category;
        }

        function getFieldLabel(key) {
            const labels = {
                host: 'Host',
                Port: 'Port',
                user: 'User',
                password: 'Password',
                name: 'Database Name',
                jwtSecret: 'JWT Secret',
                cookieSecure: 'Secure Cookie (HTTPS)',
                botSecret: 'Bot Protection Secret',
                email: 'ACME Email',
                localTlds: 'Local TLDs',
                enabled: 'Enabled',
                threshold: 'Global Threshold (req/s)',
                perIpLimit: 'Per IP Limit (req/min)',
                perIpLimitProtected: 'Protected Domains Limit (req/min)',
                verifiedIpLimit: 'Verified IP Limit (req/min)',
                burstLimit: 'Burst Limit (req/10s)',
                maxConnectionsPerIP: 'Max Connections per IP',
                maxAttempts: 'Max Challenge Attempts',
                verificationDuration: 'Verification Duration',
                challengeFirstVisit: 'Challenge First Visit',
                healthCheckInterval: 'Health Check Interval',
                failureThreshold: 'Failure Threshold',
                healthCheckTimeout: 'Health Check Timeout',
                cooldown: 'Delay Between Alerts',
                autoBlockIps: 'Auto Block IPs',
                ipBytesThreshold: 'Bytes Threshold per IP',
                ipRequestsThreshold: 'Requests Threshold per IP',
                flushInterval: 'Metrics Flush Interval',
                maxBufferSize: 'Max Buffer Size'
            };
            return labels[key] || key;
        }

        function getHelpText(key, schema) {
            const helps = {
                jwtSecret: 'At least 32 random characters',
                perIpLimit: 'Limit for unverified IPs',
                verifiedIpLimit: 'Higher limit after challenge',
                verificationDuration: 'Validity duration after successful challenge',
                localTlds: 'Local domains that do not generate certificates'
            };
            
            let text = helps[key] || '';
            if (schema.min !== undefined || schema.max !== undefined) {
                text += ` (${schema.min || 0} - ${schema.max || '∞'})`;
            }
            
            return text ? `<small class="muted">${text}</small>` : '';
        }

        async function showRuntimeDebug() {
            try {
                const response = await fetch('/api/config/runtime', {
                    credentials: 'include'
                });
                const data = await response.json();
                
                // Create a modal window with values
                const modal = document.createElement('div');
                modal.style.cssText = 'position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.8);z-index:10000;display:flex;align-items:center;justify-content:center;padding:20px;';
                
                const content = document.createElement('div');
                content.style.cssText = 'background:#1a1a1a;color:#fff;padding:30px;border-radius:8px;max-width:900px;width:100%;max-height:80vh;overflow:auto;box-shadow:0 10px 40px rgba(0,0,0,0.5);';
                content.innerHTML = `
                    <h2 style="margin-top:0;color:#fff;display:flex;align-items:center;gap:10px;">
                        🔍 Current Runtime Values
                    </h2>
                    <p style="color:#999;margin-bottom:20px;">These values are currently used by the application</p>
                    <pre style="background:#0d0d0d;color:#0f0;padding:20px;border-radius:6px;overflow:auto;font-family:monospace;font-size:13px;line-height:1.6;border:1px solid #333;">${JSON.stringify(data.runtime, null, 2)}</pre>
                    <button onclick="this.closest('div[style*=fixed]').remove()" class="btn" style="margin-top:20px;">Close</button>
                `;
                
                modal.appendChild(content);
                document.body.appendChild(modal);
                
                modal.addEventListener('click', (e) => {
                    if (e.target === modal) modal.remove();
                });
            } catch (error) {
                console.error('Failed to get runtime values:', error);
                showNotification('Error retrieving runtime values', 'error');
            }
        }

        window.addEventListener('beforeunload', (e) => {
            if (unsavedChanges.size > 0) {
                e.preventDefault();
                e.returnValue = '';
            }
        });
    </script>
</body>
</html>
