<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Configuration - Nebula Proxy</title>
    <link rel="stylesheet" href="/public/styles.css">
    <style>
        .config-tabs {
            display: flex;
            gap: 8px;
            margin-bottom: 24px;
            border-bottom: 1px solid var(--border);
            flex-wrap: wrap;
        }

        .config-tab {
            padding: 12px 20px;
            background: transparent;
            border: none;
            color: var(--text-muted);
            cursor: pointer;
            transition: all 0.3s;
            border-bottom: 2px solid transparent;
            font-weight: 500;
        }

        .config-tab:hover {
            color: var(--text-main);
        }

        .config-tab.active {
            color: var(--primary);
            border-bottom-color: var(--primary);
        }

        .config-section {
            display: none;
        }

        .config-section.active {
            display: block;
        }

        .config-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 24px;
        }

        .config-item label {
            display: block;
            color: var(--text-main);
            font-weight: 500;
            margin-bottom: 8px;
            font-size: 14px;
        }

        .config-item input[type="checkbox"] {
            width: auto;
            margin-right: 8px;
        }

        .save-indicator {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: var(--primary);
            color: var(--bg-deep);
            padding: 12px 24px;
            border-radius: var(--radius-md);
            font-weight: 600;
            display: none;
            animation: slideIn 0.3s;
            z-index: 1000;
        }

        .save-indicator.success {
            background: var(--success);
        }

        .save-indicator.error {
            background: var(--danger);
            color: #fff;
        }

        @keyframes slideIn {
            from {
                transform: translateY(100px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }
    </style>
</head>
<body data-page="config">
    <div class="app-shell">
        <div id="sidebar-placeholder"></div>
        <div class="app-main">
            <header class="topbar">
                <div class="page-heading">
                    <p class="eyebrow">Syst√®me</p>
                    <h1>Configuration</h1>
                    <p class="muted">Gestion centralis√©e de tous les param√®tres</p>
                </div>
                <div class="topbar-actions">
                    <button onclick="exportEnv()" class="btn ghost">üì• Exporter .env</button>
                    <button onclick="saveAll()" class="btn">üíæ Sauvegarder Tout</button>
                </div>
            </header>
            
            <section class="page-content">
                <div class="config-tabs" id="categoryTabs"></div>
                <div id="categoryContent"></div>
            </section>
            
            <div id="footer-placeholder"></div>
        </div>
    </div>

    <div id="saveIndicator" class="save-indicator"></div>

    <script src="/public/js/include-partials.js"></script>
    <script src="/public/js/api.js"></script>
    <script>
        let configData = {};
        let configSchema = {};
        let unsavedChanges = new Set();

        // Wait for api.js to load
        window.addEventListener('DOMContentLoaded', () => {
            setTimeout(loadConfig, 100);
        });

        async function loadConfig() {
            try {
                if (typeof api === 'undefined') {
                    console.error('API not loaded yet, retrying...');
                    setTimeout(loadConfig, 200);
                    return;
                }
                
                const data = await api.get('/api/config');
                configData = data.config;
                configSchema = data.schema;
                renderConfig();
            } catch (error) {
                console.error('Failed to load config:', error);
                showNotification('Erreur de chargement de la configuration', 'error');
            }
        }

        function renderConfig() {
            const categories = Object.keys(configSchema);
            
            const tabsHtml = categories.map(cat => `
                <button class="config-tab ${cat === categories[0] ? 'active' : ''}" 
                        onclick="switchCategory('${cat}')">
                    ${getCategoryIcon(cat)} ${getCategoryLabel(cat)}
                </button>
            `).join('');
            document.getElementById('categoryTabs').innerHTML = tabsHtml;

            const contentHtml = categories.map(cat => `
                <article class="card config-section ${cat === categories[0] ? 'active' : ''}" 
                     id="category-${cat}">
                    <div class="card-header">
                        <div>
                            <p class="eyebrow">${getCategoryLabel(cat)}</p>
                            <h2>Configuration</h2>
                        </div>
                        <button class="btn ghost small" onclick="resetCategory('${cat}')">
                            üîÑ R√©initialiser
                        </button>
                    </div>
                    <div class="config-grid">
                        ${renderCategoryFields(cat)}
                    </div>
                </article>
            `).join('');
            document.getElementById('categoryContent').innerHTML = contentHtml;
        }

        function renderCategoryFields(category) {
            const fields = configSchema[category];
            return Object.entries(fields).map(([key, schema]) => {
                const value = configData[category][key];
                const fieldId = `${category}.${key}`;
                const required = schema.required ? '*' : '';

                let inputHtml = '';
                if (schema.type === 'boolean') {
                    inputHtml = `
                        <label style="display: flex; align-items: center; cursor: pointer;">
                            <input type="checkbox" id="${fieldId}" ${value ? 'checked' : ''}
                                   onchange="markChanged('${category}', '${key}', this.checked)">
                            <span>${getFieldLabel(key)}</span>
                        </label>
                    `;
                } else if (schema.type === 'password') {
                    inputHtml = `
                        <label>${getFieldLabel(key)}${required}</label>
                        <input type="password" id="${fieldId}" value="${value || ''}" 
                               placeholder="${schema.default}"
                               onchange="markChanged('${category}', '${key}', this.value)">
                    `;
                } else if (schema.type === 'number') {
                    const unit = schema.unit ? ` ${schema.unit}` : '';
                    inputHtml = `
                        <label>${getFieldLabel(key)}${required}</label>
                        <input type="number" id="${fieldId}" value="${value || schema.default}"
                               min="${schema.min || 0}" max="${schema.max || 999999}"
                               onchange="markChanged('${category}', '${key}', Number(this.value))"
                               placeholder="${schema.default}${unit}">
                    `;
                } else if (schema.type === 'array') {
                    inputHtml = `
                        <label>${getFieldLabel(key)}${required}</label>
                        <input type="text" id="${fieldId}" 
                               value="${Array.isArray(value) ? value.join(', ') : ''}"
                               placeholder="Valeurs s√©par√©es par des virgules"
                               onchange="markChanged('${category}', '${key}', this.value.split(',').map(v => v.trim()))">
                    `;
                } else {
                    inputHtml = `
                        <label>${getFieldLabel(key)}${required}</label>
                        <input type="text" id="${fieldId}" value="${value || ''}" 
                               placeholder="${schema.default}"
                               onchange="markChanged('${category}', '${key}', this.value)">
                    `;
                }

                return `
                    <div class="config-item">
                        ${inputHtml}
                        ${getHelpText(key, schema)}
                    </div>
                `;
            }).join('');
        }

        function switchCategory(category) {
            document.querySelectorAll('.config-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            event.target.classList.add('active');

            document.querySelectorAll('.config-section').forEach(content => {
                content.classList.remove('active');
            });
            document.getElementById(`category-${category}`).classList.add('active');
        }

        function markChanged(category, key, value) {
            configData[category][key] = value;
            unsavedChanges.add(`${category}.${key}`);
            
            clearTimeout(window.autoSaveTimer);
            window.autoSaveTimer = setTimeout(() => {
                saveChanges(category, key, value);
            }, 1000);
        }

        async function saveChanges(category, key, value) {
            try {
                await api.put('/api/config', { category, key, value });
                unsavedChanges.delete(`${category}.${key}`);
                showNotification('‚úì Sauvegard√©', 'success');
            } catch (error) {
                console.error('Failed to save:', error);
                showNotification('Erreur de sauvegarde', 'error');
            }
        }

        async function saveAll() {
            if (unsavedChanges.size === 0) {
                showNotification('Aucun changement √† sauvegarder', 'success');
                return;
            }

            const updates = Array.from(unsavedChanges).map(key => {
                const [category, field] = key.split('.');
                return {
                    category,
                    key: field,
                    value: configData[category][field]
                };
            });

            try {
                await api.post('/api/config/bulk', { updates });
                unsavedChanges.clear();
                showNotification(`‚úì ${updates.length} param√®tres sauvegard√©s`, 'success');
            } catch (error) {
                console.error('Failed to save all:', error);
                showNotification('Erreur de sauvegarde', 'error');
            }
        }

        async function resetCategory(category) {
            if (!confirm(`R√©initialiser tous les param√®tres de ${getCategoryLabel(category)} ?`)) {
                return;
            }

            try {
                await api.post('/api/config/reset', { category });
                await loadConfig();
                showNotification('‚úì R√©initialis√©', 'success');
            } catch (error) {
                console.error('Failed to reset:', error);
                showNotification('Erreur', 'error');
            }
        }

        async function exportEnv() {
            window.location.href = '/api/config/export';
        }

        function showNotification(message, type = 'success') {
            const indicator = document.getElementById('saveIndicator');
            indicator.textContent = message;
            indicator.className = `save-indicator ${type}`;
            indicator.style.display = 'block';
            
            setTimeout(() => {
                indicator.style.display = 'none';
            }, 3000);
        }

        function getCategoryIcon(category) {
            const icons = {
                database: 'üóÑÔ∏è',
                security: 'üîí',
                acme: 'üîê',
                botProtection: 'üõ°Ô∏è',
                backends: 'üñ•Ô∏è',
                alerts: 'üö®',
                ipSecurity: 'üö´',
                metrics: 'üìä'
            };
            return icons[category] || '‚öôÔ∏è';
        }

        function getCategoryLabel(category) {
            const labels = {
                database: 'Base de Donn√©es',
                security: 'S√©curit√© & JWT',
                acme: 'SSL / Let\'s Encrypt',
                botProtection: 'Protection Bot / DDoS',
                backends: 'Backends & Health Check',
                alerts: 'Alertes',
                ipSecurity: 'S√©curit√© IP',
                metrics: 'M√©triques'
            };
            return labels[category] || category;
        }

        function getFieldLabel(key) {
            const labels = {
                host: 'H√¥te',
                port: 'Port',
                user: 'Utilisateur',
                password: 'Mot de passe',
                name: 'Nom de la base',
                jwtSecret: 'Secret JWT',
                cookieSecure: 'Cookie s√©curis√© (HTTPS)',
                botSecret: 'Secret Bot Protection',
                email: 'Email ACME',
                localTlds: 'TLDs locaux',
                enabled: 'Activ√©',
                threshold: 'Seuil global (req/s)',
                perIpLimit: 'Limite par IP (req/min)',
                perIpLimitProtected: 'Limite domaines prot√©g√©s (req/min)',
                verifiedIpLimit: 'Limite IP v√©rifi√©es (req/min)',
                burstLimit: 'Limite burst (req/10s)',
                maxConnectionsPerIP: 'Connexions max par IP',
                maxAttempts: 'Tentatives max challenge',
                verificationDuration: 'Dur√©e v√©rification',
                challengeFirstVisit: 'Challenge 1√®re visite',
                healthCheckInterval: 'Intervalle health check',
                failureThreshold: 'Seuil d\'√©checs',
                healthCheckTimeout: 'Timeout health check',
                cooldown: 'D√©lai entre alertes',
                autoBlockIps: 'Blocage auto IPs',
                ipBytesThreshold: 'Seuil bytes par IP',
                ipRequestsThreshold: 'Seuil requ√™tes par IP',
                flushInterval: 'Intervalle flush m√©triques',
                maxBufferSize: 'Taille max buffer'
            };
            return labels[key] || key;
        }

        function getHelpText(key, schema) {
            const helps = {
                jwtSecret: 'Au moins 32 caract√®res al√©atoires',
                perIpLimit: 'Limite pour IPs non v√©rifi√©es',
                verifiedIpLimit: 'Limite plus √©lev√©e apr√®s challenge',
                verificationDuration: 'Dur√©e de validit√© apr√®s challenge r√©ussi',
                localTlds: 'Domaines locaux qui ne g√©n√®rent pas de certificat'
            };
            
            let text = helps[key] || '';
            if (schema.min !== undefined || schema.max !== undefined) {
                text += ` (${schema.min || 0} - ${schema.max || '‚àû'})`;
            }
            
            return text ? `<small class="muted">${text}</small>` : '';
        }

        window.addEventListener('beforeunload', (e) => {
            if (unsavedChanges.size > 0) {
                e.preventDefault();
                e.returnValue = '';
            }
        });
    </script>
</body>
</html>
