<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Configuration - Nebula Console</title>
  <link rel="stylesheet" href="/public/nebula-v2.css">
  <script src="/public/js/theme.js"></script>
  <script src="/public/js/api.js" defer></script>
  <script src="/public/js/include-partials.js" defer></script>
  <script src="/public/js/app.js" defer></script>
</head>

<body data-page="config">
  <div class="app-shell">
    <div id="sidebar-placeholder"></div>

    <div class="app-main">
      <header class="topbar">
        <div class="page-heading">
          <p class="eyebrow">System</p>
          <h1>Configuration</h1>
          <p class="muted">Centralized management of all settings</p>
        </div>
        <div class="topbar-actions">
          <button onclick="showRuntimeDebug()" class="btn ghost small" title="View current runtime values">
            Debug
          </button>
          <button onclick="exportEnv()" class="btn ghost">Export .env</button>
          <button onclick="saveAll()" class="btn btn-primary">Save All</button>
          <button onclick="restartApp()" class="btn btn-danger" id="restartBtn" hidden>
            Restart
          </button>
        </div>
      </header>

      <section class="page-content">
        <div id="dbAlert" class="db-alert" hidden>
          <div class="db-alert-icon">‚ö†Ô∏è</div>
          <div class="db-alert-content">
            <div class="db-alert-title">Database connection failed</div>
            <div class="db-alert-message" id="dbAlertMessage">
              Unable to connect to PostgreSQL database
            </div>
          </div>
          <div class="db-alert-actions">
            <button onclick="testDatabaseConnection()" class="btn ghost btn-sm" id="testDbBtn">
              Test Connection
            </button>
          </div>
        </div>

        <div class="config-tabs" id="categoryTabs"></div>
        <div id="categoryContent"></div>
      </section>

      <div id="footer-placeholder"></div>
    </div>
  </div>

  <div id="saveIndicator" class="save-indicator" hidden></div>
  <script>
    let configData = {};
    let configSchema = {};
    let unsavedChanges = new Set();

    window.addEventListener('DOMContentLoaded', () => {
      setTimeout(() => {
        loadConfig();
        checkDatabaseConnection();
      }, 100);
    });

    async function checkDatabaseConnection() {
      try {
        if (typeof api === 'undefined') {
          setTimeout(checkDatabaseConnection, 200);
          return;
        }

        const response = await fetch('/api/config/test-db', {
          method: 'GET',
          headers: { 'Content-Type': 'application/json' },
          credentials: 'include'
        });

        const result = await response.json();

        if (!result.success) {
          showDatabaseAlert(result.error || 'Database connection failed');
        } else {
          hideDatabaseAlert();
        }
      } catch (error) {
        console.error('Failed to check database:', error);
        showDatabaseAlert('Unable to verify database connection');
      }
    }

    function showDatabaseAlert(message) {
      const alert = document.getElementById('dbAlert');
      const messageEl = document.getElementById('dbAlertMessage');
      messageEl.textContent = message;
      alert.hidden = false;
    }

    function hideDatabaseAlert() {
      document.getElementById('dbAlert').hidden = true;
    }

    async function testDatabaseConnection() {
      const btn = document.getElementById('testDbBtn');
      const originalText = btn.textContent;
      btn.textContent = 'Testing...';
      btn.disabled = true;

      try {
        const response = await fetch('/api/config/test-db', {
          method: 'GET',
          headers: { 'Content-Type': 'application/json' },
          credentials: 'include'
        });

        const result = await response.json();

        if (result.success) {
          hideDatabaseAlert();
          showNotification('‚úì Database connection successful', 'success');
        } else {
          showDatabaseAlert(result.error || 'Connection failed');
          showNotification('Connection failed: ' + result.error, 'error');
        }
      } catch (error) {
        console.error('Test failed:', error);
        showNotification('Connection test error', 'error');
      } finally {
        btn.textContent = originalText;
        btn.disabled = false;
      }
    }

    async function loadConfig() {
      try {
        if (typeof api === 'undefined') {
          console.error('API not loaded yet, retrying...');
          setTimeout(loadConfig, 200);
          return;
        }

        const data = await api.get('/api/config');
        configData = data.config;
        configSchema = data.schema;
        renderConfig();
      } catch (error) {
        console.error('Failed to load config:', error);
        showNotification('Configuration loading error', 'error');
      }
    }

    function renderConfig() {
      const categories = Object.keys(configSchema);

      const tabsHtml = categories.map(cat => `
        <button class="config-tab ${cat === categories[0] ? 'active' : ''}"
                onclick="switchCategory('${cat}')">
          ${getCategoryIcon(cat)} ${getCategoryLabel(cat)}
        </button>
      `).join('');
      document.getElementById('categoryTabs').innerHTML = tabsHtml;

      const contentHtml = categories.map(cat => `
        <article class="card config-section ${cat === categories[0] ? 'active' : ''}"
             id="category-${cat}">
          <div class="card-header">
            <div>
              <p class="card-eyebrow">${getCategoryLabel(cat)}</p>
              <h2 class="card-title">Configuration</h2>
            </div>
            <button class="btn ghost small" onclick="resetCategory('${cat}')">
              Reset
            </button>
          </div>
          <div class="card-body">
            <div class="config-grid">
              ${renderCategoryFields(cat)}
            </div>
          </div>
        </article>
      `).join('');
      document.getElementById('categoryContent').innerHTML = contentHtml;
    }

    function renderCategoryFields(category) {
      const fields = configSchema[category];

      let headerMessage = '';
      if (category === 'database') {
        headerMessage = `
          <div class="alert alert-info">
            These settings modify the <code>.env</code> file. Application restart will be required after save.
          </div>
        `;
      }

      const fieldsHtml = Object.entries(fields).map(([key, schema]) => {
        const value = configData[category][key];
        const fieldId = `${category}.${key}`;
        const required = schema.required ? '*' : '';

        let inputHtml = '';
        if (schema.type === 'boolean') {
          inputHtml = `
            <label class="form-check">
              <input type="checkbox" id="${fieldId}" ${value ? 'checked' : ''}
                     onchange="markChanged('${category}', '${key}', this.checked, ${schema.requiresRestart || false})">
              <span>${getFieldLabel(key)}</span>
            </label>
          `;
        } else if (schema.type === 'password') {
          inputHtml = `
            <label>${getFieldLabel(key)}${required}</label>
            <input type="password" id="${fieldId}" value="${value || ''}"
                   placeholder="${schema.default}"
                   onchange="markChanged('${category}', '${key}', this.value, ${schema.requiresRestart || false})">
          `;
        } else if (schema.type === 'number') {
          const unit = schema.unit ? ` ${schema.unit}` : '';
          inputHtml = `
            <label>${getFieldLabel(key)}${required}</label>
            <input type="number" id="${fieldId}" value="${value || schema.default}"
                   min="${schema.min || 0}" max="${schema.max || 999999}"
                   onchange="markChanged('${category}', '${key}', Number(this.value), ${schema.requiresRestart || false})"
                   placeholder="${schema.default}${unit}">
          `;
        } else if (schema.type === 'array') {
          inputHtml = `
            <label>${getFieldLabel(key)}${required}</label>
            <input type="text" id="${fieldId}"
                   value="${Array.isArray(value) ? value.join(', ') : ''}"
                   placeholder="Comma-separated values"
                   onchange="markChanged('${category}', '${key}', this.value.split(',').map(v => v.trim()), ${schema.requiresRestart || false})">
          `;
        } else {
          inputHtml = `
            <label>${getFieldLabel(key)}${required}</label>
            <input type="text" id="${fieldId}" value="${value || ''}"
                   placeholder="${schema.default}"
                   onchange="markChanged('${category}', '${key}', this.value, ${schema.requiresRestart || false})">
          `;
        }

        return `
          <div class="config-item">
            ${inputHtml}
            ${getHelpText(key, schema)}
          </div>
        `;
      }).join('');

      return headerMessage + fieldsHtml;
    }

    function switchCategory(category) {
      document.querySelectorAll('.config-tab').forEach(tab => {
        tab.classList.remove('active');
      });
      event.target.classList.add('active');

      document.querySelectorAll('.config-section').forEach(content => {
        content.classList.remove('active');
      });
      document.getElementById(`category-${category}`).classList.add('active');
    }

    function markChanged(category, key, value, requiresRestart = false) {
      configData[category][key] = value;
      const changeKey = `${category}.${key}`;
      unsavedChanges.add(changeKey);

      if (requiresRestart) {
        if (!window.changesRequiringRestart) {
          window.changesRequiringRestart = new Set();
        }
        window.changesRequiringRestart.add(changeKey);
      }

      clearTimeout(window.autoSaveTimer);
      window.autoSaveTimer = setTimeout(() => {
        saveChanges(category, key, value, requiresRestart);
      }, 1000);
    }

    async function saveChanges(category, key, value, requiresRestart = false) {
      try {
        if (requiresRestart) {
          const updates = {};
          updates[key] = value;

          const response = await fetch('/api/config/update-env', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            credentials: 'include',
            body: JSON.stringify({ category, updates })
          });

          const result = await response.json();

          unsavedChanges.delete(`${category}.${key}`);
          showNotification('‚úì Saved in .env - Restart required', 'success');

          const restartBtn = document.getElementById('restartBtn');
          if (restartBtn) {
            restartBtn.hidden = false;
          }
        } else {
          await api.put('/api/config', { category, key, value });
          unsavedChanges.delete(`${category}.${key}`);
          showNotification('‚úì Saved', 'success');
        }
      } catch (error) {
        console.error('Failed to save:', error);
        showNotification('Save error', 'error');
      }
    }

    async function saveAll() {
      if (unsavedChanges.size === 0) {
        showNotification('No changes to save', 'success');
        return;
      }

      const dbUpdates = [];
      const envUpdatesByCategory = {};
      let hasEnvChanges = false;

      for (const changeKey of unsavedChanges) {
        const [category, field] = changeKey.split('.');
        const schema = configSchema[category]?.[field];

        if (schema?.requiresRestart) {
          if (!envUpdatesByCategory[category]) {
            envUpdatesByCategory[category] = {};
          }
          envUpdatesByCategory[category][field] = configData[category][field];
          hasEnvChanges = true;
        } else {
          dbUpdates.push({
            category,
            key: field,
            value: configData[category][field]
          });
        }
      }

      try {
        for (const [category, updates] of Object.entries(envUpdatesByCategory)) {
          await fetch('/api/config/update-env', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            credentials: 'include',
            body: JSON.stringify({ category, updates })
          });
        }

        if (dbUpdates.length > 0) {
          await api.post('/api/config/bulk', { updates: dbUpdates });
        }

        unsavedChanges.clear();

        if (hasEnvChanges) {
          showNotification(`‚úì .env file updated - RESTART REQUIRED`, 'success');
          const restartBtn = document.getElementById('restartBtn');
          if (restartBtn) {
            restartBtn.hidden = false;
          }
        } else {
          showNotification(`‚úì ${dbUpdates.length} settings saved`, 'success');
        }
      } catch (error) {
        console.error('Failed to save all:', error);
        showNotification('Save error', 'error');
      }
    }

    async function restartApp() {
      if (!confirm('Reload configuration now? New database values will be applied.')) {
        return;
      }

      const restartBtn = document.getElementById('restartBtn');
      restartBtn.disabled = true;
      restartBtn.textContent = 'Reloading...';

      showNotification('Reloading configuration...', 'success');

      try {
        const response = await fetch('/api/system/restart', {
          method: 'POST',
          credentials: 'include'
        });

        const result = await response.json();

        if (result.success) {
          if (result.dbConnected) {
            showNotification('‚úì Configuration reloaded - Database reconnected!', 'success');

            restartBtn.hidden = true;
            hideDatabaseAlert();

            setTimeout(() => {
              window.location.reload();
            }, 1500);
          } else {
            showNotification('‚ö†Ô∏è Configuration reloaded but DB remains unreachable: ' + (result.error || 'Unknown error'), 'error');
            restartBtn.disabled = false;
            restartBtn.textContent = 'Restart';

            setTimeout(checkDatabaseConnection, 1000);
          }
        } else {
          showNotification('Reload failed: ' + (result.message || 'Unknown error'), 'error');
          restartBtn.disabled = false;
          restartBtn.textContent = 'Restart';
        }
      } catch (error) {
        console.error('Restart error:', error);
        showNotification('Error reloading configuration', 'error');
        restartBtn.disabled = false;
        restartBtn.textContent = 'Restart';
      }
    }

    async function resetCategory(category) {
      if (!confirm(`Reset all settings for ${getCategoryLabel(category)}?`)) {
        return;
      }

      try {
        await api.post('/api/config/reset', { category });
        await loadConfig();
        showNotification('‚úì Reset', 'success');
      } catch (error) {
        console.error('Failed to reset:', error);
        showNotification('Error', 'error');
      }
    }

    async function exportEnv() {
      window.location.href = '/api/config/export';
    }

    function showNotification(message, type = 'success') {
      const indicator = document.getElementById('saveIndicator');
      indicator.textContent = message;
      indicator.className = `save-indicator save-${type}`;
      indicator.hidden = false;

      setTimeout(() => {
        indicator.hidden = true;
      }, 3000);
    }

    function getCategoryIcon(category) {
      const icons = {
        database: 'üóÑÔ∏è',
        security: 'üîê',
        acme: 'üîí',
        botProtection: 'ü§ñ',
        backends: '‚öôÔ∏è',
        alerts: 'üîî',
        ipSecurity: 'üõ°Ô∏è',
        metrics: 'üìä'
      };
      return icons[category] || '‚öôÔ∏è';
    }

    function getCategoryLabel(category) {
      const labels = {
        database: 'Database',
        security: 'Security & JWT',
        acme: 'SSL / Let\'s Encrypt',
        botProtection: 'Bot / DDoS Protection',
        backends: 'Backends & Health Check',
        alerts: 'Alerts',
        ipSecurity: 'IP Security',
        metrics: 'Metrics'
      };
      return labels[category] || category;
    }

    function getFieldLabel(key) {
      const labels = {
        host: 'Host',
        port: 'Port',
        user: 'User',
        password: 'Password',
        name: 'Database Name',
        jwtSecret: 'JWT Secret',
        cookieSecure: 'Secure Cookie (HTTPS)',
        botSecret: 'Bot Protection Secret',
        email: 'ACME Email',
        localTlds: 'Local TLDs',
        enabled: 'Enabled',
        threshold: 'Global Threshold (req/s)',
        perIpLimit: 'Per IP Limit (req/min)',
        perIpLimitProtected: 'Protected Domains Limit (req/min)',
        verifiedIpLimit: 'Verified IP Limit (req/min)',
        burstLimit: 'Burst Limit (req/10s)',
        maxConnectionsPerIP: 'Max Connections per IP',
        maxAttempts: 'Max Challenge Attempts',
        verificationDuration: 'Verification Duration',
        challengeFirstVisit: 'Challenge First Visit',
        healthCheckInterval: 'Health Check Interval',
        failureThreshold: 'Failure Threshold',
        healthCheckTimeout: 'Health Check Timeout',
        cooldown: 'Delay Between Alerts',
        autoBlockIps: 'Auto Block IPs',
        ipBytesThreshold: 'Bytes Threshold per IP',
        ipRequestsThreshold: 'Requests Threshold per IP',
        flushInterval: 'Metrics Flush Interval',
        maxBufferSize: 'Max Buffer Size'
      };
      return labels[key] || key;
    }

    function getHelpText(key, schema) {
      const helps = {
        jwtSecret: 'At least 32 random characters',
        perIpLimit: 'Limit for unverified IPs',
        verifiedIpLimit: 'Higher limit after challenge',
        verificationDuration: 'Validity duration after successful challenge',
        localTlds: 'Local domains that do not generate certificates'
      };

      let text = helps[key] || '';
      if (schema.min !== undefined || schema.max !== undefined) {
        text += ` (${schema.min || 0} - ${schema.max || '‚àû'})`;
      }

      return text ? `<p class="form-hint">${text}</p>` : '';
    }

    async function showRuntimeDebug() {
      try {
        const response = await fetch('/api/config/runtime', {
          credentials: 'include'
        });
        const data = await response.json();

        const modal = document.createElement('div');
        modal.className = 'panel-overlay';

        const content = document.createElement('div');
        content.className = 'panel-card debug-modal';
        content.innerHTML = `
          <div class="panel-head">
            <div>
              <h2>Current Runtime Values</h2>
              <p class="muted">These values are currently used by the application</p>
            </div>
            <button onclick="this.closest('.panel-overlay').remove()" class="btn ghost small">Close</button>
          </div>
          <div class="debug-content">
            <pre>${JSON.stringify(data.runtime, null, 2)}</pre>
          </div>
        `;

        modal.appendChild(content);
        document.body.appendChild(modal);

        modal.addEventListener('click', (e) => {
          if (e.target === modal) modal.remove();
        });
      } catch (error) {
        console.error('Failed to get runtime values:', error);
        showNotification('Error retrieving runtime values', 'error');
      }
    }

    window.addEventListener('beforeunload', (e) => {
      if (unsavedChanges.size > 0) {
        e.preventDefault();
        e.returnValue = '';
      }
    });
  </script>
</body>
</html>
